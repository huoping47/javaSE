package gather.demo

/*          集合
1、什么是集合？有什么用？
        数组就是一个集合，集合实际上就是一个容器，可以来容纳其他类型的数据
        集合为什么在开发中使用较多？
            集合是一个容器，是一个载体，可以一次容纳多个对象
            在实际开发中，假设连接数据库，数据库当中有10条对象
            那么假设把这10条记录查询出来，在java程序中会将10条数据
            封装成10个java对象，然后将10个java对象放到某一个集合当中
            将集合传到前段，然后遍历集合，将一个数据一个个数据展现出来
    1.2、集合不能直接存储基本数据类型，另外集合也不能直接存储java对象
        集合当中存储的都是java对象的内存地址（或者说集合中存储的是引用）
        集合本身就是一个对象，也有内存地址
        
    1.3、在java中每一个不同的集合，底层会对应不同的数据结构，往不同的集合中存储元素
    等于将数据放到了不同的数据结构当中，什么是数据结构？数据存储的结构就是数据结构，不同
    的数据结构，数据存储方式不同，例如：
        new ArrayList();   底层是一个数组的集合      初始化的容量是10，扩容是原容量的1.5倍，二进制右移一位
        new  TreeSet();    底层是一个二叉树的集合
        new LinkedList();  底层是一个链表的集合       LinkedList是一个双向链表，随机增删效率高，检索效率低
        
    1.4、在java中集合分为两大类：
        一类是单个方式存储元素：
            单个方式存储元素，这一类集合中超级父接口：java.util.Collection
        一类是以键值对儿的方式存储元素
            以键值对的方式存储元素，这一类集合中超级父接口：java.util.Map

集合关于java中Collection接口中常用的方法
    1、collection中能存放什么元素？
        没有使用“泛型”之前，Collection中存储Object的所有子类型
        使用了“泛型”之后，Collection中只能存储某个具体的类型，
        Collection中什么都能存，只要是Object的子类型就行，（集合
        中不能直接存储基本数据类型，也不能存java对象，只是存储java对象的内存地址）
    2、Collection中的常用方法
        boolean   add  (Object e)     向集合中添加元素
        int   size()    获取集合中元素的个数
        void clear()    清空集合
        boolean contains    (Object o)      判断集合中是否包含某个元素
        boolean remove  (Object o)      删除集合中的某个元素
        boolean isEmpty()       判断集合中是否为空
        

单向列表：
    单链表中的节点，节点是单向链表中基本的单元，每一个节点Node都有两个属性：一个属性是：存储的数据
    另一个属性：是下一个节点的内存地址
    
    单向链表优点：是由节点组成，节点里面有数据和下一个节点的内存的地址
        随机增删效率较高
        缺点是：查询效率较低，每一次查找的时候都需要从头节点开始遍历
    双向链表：节点里面包含上一个节点的内存地址和数据，同时还包含下一个节点的内存地址
    
    
怎么把非线程安全的转换成线程安全的？
    java.util.collection是一个接口
    java.util.collections是一个工具类
    使用collections下面的synchronizedl的方法，然后参数传集合就可以了

 HashMap集合：
 *      底层是一个哈希表/散列表的数据结构
 *      哈希列表是怎么样数据结构呢？
 *          哈希表是一个数组和单项链表的结合体
 *          数组：在查询方面效率很高，随机增删方面效率很低
 *          单向链表：在查询方面效率低，但是随机增删方面效率很高
 *          哈希表将两种数组结构联合起来，充分发挥他们各自的优点
 *
 *          HashMap集合的key部分特点：
 *              无序，不可重复
 *              为什么无序？因为不一定挂到哪个单向链表上
 *              不可重复是调用Equals方法来保证HashMao集合的key不可重复，如果key重复了，value会覆盖
 *              放在HashMap集合key部分的元素其实就是方法Hashset中了，所以HashSet集合中的元素也需要重写HashCode
 *              和equals方法
 *              注意：如果一个类的equals方法重写了，那么hashCode方法必须重写，并且equals方法返回如果是true，
 hashCode方法返回的值必须一样，equals方法返回true表示两个对象相同，在同一个单向链表上比较，那么对于同一个
 单向链表上的节点来说，他们的哈希值都是相同的，所以hashCode方法的返回值也应该相同

结论：放在HashMap集合key部分的，以及放在HashSet集合的元素，需要同时重写HasgCode和equals方法

TreeMap集合
    1、TreeMap集合底层实际上是一个TreeMap
    2、TreeMap集合底层是一个二叉树
    3、放到TreeSet集合中的元素，等同于方法哦TreeMap集合中的key部分了
    4、TreeSet集合中的元素：无序不可重复，但是可以按照元素的大小顺序自动排序

比较器
放到TreeSet或者TreeMap集合key部分的元素要想做到排序，包括两种方式：
     第一种：放在集合中的元素实现java.lang.Compareble接口
     第二种：在构造TreeSet或者TreeMap集合的时候给他传一个比较器对象
     Compareble和Comparetor怎么选择？
         当比较规则不会发生改变时候，或者说当比较规则只有1个的时候，建议使用Comparable接口
         当比较规则有多个，并且需要多个比较规则之间频繁切换，建议使用Comparator接口









 */