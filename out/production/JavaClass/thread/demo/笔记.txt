                                            多线程
什么是多线程？
    1、进程是一个应用程序（1个进程是一个软件）
    线程是一个进程中的执行场景/执行单元
    一个进程可以启动多个线程
    2、对于java程序来说，当DOS命令窗口中输入：
        java HelloWord回车之后
        会先启动JVM，而JVM就是一个进程
        JVM再启动一个垃圾回收线程负责看护，回收垃圾
        最起码，现在的java程序中至少有两个线程并发
        一个是垃圾回收线程，一个是执行main方法的主线程
    3、进程和线程是什么关系？
        比如：京东：进程
                        刘强冬就是一个京东的线程
                        妹妹也是刘强东的一个线程
        比如有两个进程，进程A和进程B的资源不会共享
            那么线程A和线程B呢？
                在java语言中，线程A和线程B，堆内存和方法去内存共享，但是栈内存独立，一个线程一个栈

                假设启动10个线程，会有10个栈空间，每个栈和每个栈之间互不干扰，各自执行各自的，这就是多线程并发
                多线程并发可以提高效率，这也就是多线程的一个机制

            线程是进程的一个执行场景，一个执行过程

        4、使用了多线程机制之后，就算main方法结束了，其他的程序也不会结束，main方法结束之时主线程结束了，主栈空了，
        其他的栈（线程）可能还在压栈弹栈

        5、java语言中，实现线程有两种方式
            第一种：编写一个类，直接继承java.lang.Thread，重写run方法
                在run方法当中，就是编写分支线程需要执行的代码
                启动线程调用start的方法，这个方法只是负责开辟一个新的栈空间，开辟出来了之后这段代码马上就结束了，线程就启动了
                启动成功的线程会自动调用run方法，并且run方法在分支栈的底部（压栈）
                run方法在分支栈的栈底部，main方法在主栈的栈底部，run和main是平级的
                如果类直接调用run方法，那么就没有启动分支线程，这样的话就是单线程了

            第二种：编写一个类实现java.lang.Runnable接口


关于线程的声明周期：
    新建状态，就绪状态，运行状态，阻塞状态，死亡状态

关于多线程并发环境下，线程的安全问题
    1、以后在开发中,我们的项目都是运行在服务器当中，而服务器已经将线程的定义，线程对象的创建，线程的启动等，都已经实现完了，这些代码不需要我们编写

    2、什么时候数据在多线程并发的环境下会存在安全问题呢？
        条件一：多线程并发
        条件二：有共享数据
        条件三：共享数据有修改的行为
        满足以上三个条件之后，就会存在线程安全问题

        怎么解决线程安全的问题呢？将共享数据写到synchronized里面
            线程排队执行（不能并发）用排队执行解决线程安全问题，这种机制被称为‘线程同步机制’，线程同步机制会牺牲一部分效率，但是数据安全比效率更重要

            线程同步涉及到两块
                异步编程模型：
                线程t和线程t1，各自执行各自的，t不管t1，t1不管t，其实就是多线程并发， 效率较高
                同步编程模型：
                线程t和线程t1，在线程t执行的时候，必须等待t1线程执行结束，或者说在t1线程执行的时候，t必须等待t1线程执行结束，两个线程需要互相等待
                这就是同步编程模型，效率较低，线程排队执行

    JAVA中有三大变量：
        局部变量
        实例变量
        静态变量
        以上三大变量中，局部变量是永远不会存在线程安全问题，因为局部变量不是共享的，局部变量在栈中，所以局部变量永远不会共享
        实例变量在堆中，堆只有一个
        静态变量在方法区中，方法区只有一个，堆和方法区都是多线程共享的，所以可能存在线程安全问题

synchronized可以写在实例方法上面，synchronized出现在实例方法上，一定锁的是this，没得选，不能是其他的对象了，所以这种方式不灵活
另外还有一个缺点：synchronized出现在实例方法上，表示整个方法体都需要同步，可能会无故扩大同步的范围，导致程序的执行效率降低，所以这种方式不常用

synchronized使用在实例方法上有什么优点呢？ 那就是代码写的少了，节俭了

如果共享的对象就是this，并且需要同步的代码块是整个方法体，那么就可以使用synchronized

守护线程：
    JAVA语言中线程分为两大类：
        一类是：用户线程
        一类是：守护线程（后台线程）
        其中具有代表性的就是：垃圾回收线程（守护线程）
    守护线程的特点：
        一般守护线程是一个死循环，所有的用户线程只要结束，守护线程自动结束
    守护线程用在什么地方呢？
        每天24点的时候系统数据自动备份，这个需要使用到定时器，并且我们可以将定时器设置为守护线程
        一直在那里看着，每到24点的时候就备份一次，所有的用户线程如果结束了，守护线程自动退出，没有必要备份数据了

    定时器：
        定时器的作用就是间隔特定的时间，执行特定的程序，每周要进行银行账户的总账操作，每天要进行数据的备份操作...等等

    实现线程的第三种方式：实现Callable接口，之前的方式实现的线程可以获取线程的返回值，之间的两种方式是无法获取
    线程的返回值的，因为run方法是void
    这种方式的话就是效率比较低，但是可以获取到当前线程的执行结果

关于Object类中的wait和notify方法：
    第一：wait和notify方法不是线程对象的方法，是java中任何一个java对象都有的方法，因为这两个方式是Object类
    中自带的
    第二：wait方法的作用：表示正在让某个对象上活动的线程进入等待状态，无期限等待，直到被唤醒为止
    第三：notify方法的作用：这个方法的调用可以让正在该对象上正在等待的线程唤醒




